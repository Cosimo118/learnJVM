### 2.4.1　java堆溢出

+ 堆溢出的原因就是对象过多。可以分为内存泄露和内存溢出
  + 内存泄露(memory leak)打开的对象无法关闭，无法回收这块内存空间
  + 内存溢出(memory overflow)要使用的内存比申请到的内存大，内存不够用

### 2.4.2　虚拟机栈和本地方法栈溢出

* 如果线程请求的栈深度大于虚拟机所允许的最大深度，抛出stackOverflowError
* 如果虚拟机在扩展栈时无法申请到足够的内存空间，抛出OutOfMemoryError
* 在单线程情况下，只出现stackOverFlowError
* 多线程情况下，比较容易出现OutOfMemoryError
* 因为：32位的java虚拟机内存容量有限，在刨去堆内存空间，方法区空间后，剩下的内存分给虚拟机栈和本地方法栈，所以线程越多，就越容易整体超出内存，出现outofmemoryerror。
* 对stackOverFlowError，一般的方法调用，栈深度达到1000-2000不成问题，应该都够用；
* 如果是过多线程导致的内存溢出，如果不能减少线程数或更换64位虚拟机，就只能通过减少最大堆和减少栈容量来换取更多的线程。

### 2.4.3　方法区和运行时常量池溢出

* JDK1.6中，运行时常量池和方法区都属于永久代的一部分，不断创建新常量会出现OOM异常
* JDK1.7中，逐步去永久代
* 方法区溢出也是一种常见的内存溢出异常，
* 一个类要被垃圾收集器回收掉，判定条件是很苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收情况。

### 2.4.4　本机直接内存溢出

* 直接内存可以指定，默认值和java堆最大值一样。
* 由直接内存导致的溢出，明显特征是heap dump文件中不会看见明显异常，如果oom之后dump文件很小，程序中又直接或间接的使用了NIO，可以考虑是本机直接内存溢出这项问题。