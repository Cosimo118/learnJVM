## 2.1运行时数据区域

### 2.2.1 程序计数器

+ 当前线程所执行字节码的行号指示器
+ 每个线程都需要有一个独立的程序计数器，因此，程序计数器是“线程私有”的
+ 此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

### 2.2.2 Java虚拟机栈

+ java虚拟机栈也是线程私有的，生命周期与线程相同
+ 虚拟机栈与java方法息息相关，每个方法调用时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息
+ 每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机战中入栈到出栈的过程
+ 局部变量表里存储了基本数据类型，对象引用和returnAddress类型
+ 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小
+ 如果线程过多，请求的栈深度超过了虚拟机所允许的深度，抛出StackOverFlow异常
+ 如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，抛出OutOfMemoryError

### 2.2.3 本地方法栈

+ 与java虚拟机栈类似，不同的是为本地方法栈服务的是虚拟机使用到的native方法，也会抛出StackOverFlowError和OutOfMemoryError

### 2.2.4 java堆

+ java堆是虚拟机管理内存中最大的一块
+ java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，用于存放对象实例
+ java堆是垃圾收集器管理的主要区域，因此也被称作GC堆(Garbage Collected Heap)
+ 考虑到分代收集算法，还可以细分为：新生代和老年代
+ 线程共享的java堆中也可以划分出多个线程私有的分配缓冲区，但无论哪个区域，存储的都是对象实例。
+ java堆可以处于物理上不连续的内存空间上，只要逻辑上是连续的即可。
+ 堆中没有内存完成实例分配，或者堆也无法再扩展时，将会抛出OutOfMemoryError

### 2.2.5方法区

+ 方法区和堆一样，是线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
+ 方法区被描述为堆的一个逻辑部分，但却有一个别名叫(non-heap)，目的是与java堆区分开来
+ 在hotspot虚拟机上，方法区也被叫做(permanent generation)永久代，意为用GC来管理这部分内存。
+ 方法区进行内存回收时，主要回收常量池和卸载类型
+ 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError

### 2.2.6 运行时常量池

+ 运行时常量池(runtime constant pool)是方法区的一部分
+ class文件中的常量池用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放
+ 运行时常量池的重要特征是具备动态性。JAVA语言并不要求常量一定只有编译期才能产生，也就是并非预置入class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中。
+ 和方法区一样，常量池无法申请到内存时会报OutOfMemoryError

### 2.2.7　直接内存

+ 直接内存不在java虚拟机规定的范围内，属于native，虽然不受到java堆大小的限制，但也受到本机总内存大小及处理器寻址空间的限制，导致动态扩展时可能出现OutOfMemoryError

