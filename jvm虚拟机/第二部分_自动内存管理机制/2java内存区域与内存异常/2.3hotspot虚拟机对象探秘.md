## 2.3 hotspot虚拟机对象探秘

+ 了解对象创建的细节，如何布局以及如何访问的
+ 以hotspot虚拟机和常用的内存区域heap为例，深入探讨hotspot虚拟机在java堆中对象分配、布局和访问的全过程

### 2.3.1对象的创建

+ 虚拟机遇到一条new指令，先检查该指令的参数能否在常量池中定位道一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，没有的话先执行相应的类加载过程
+ 接下来为对象分配内存，等于从java堆中划分出一块确定大小的内存
  + java堆中内存是规整的：指针碰撞(bump the pointer)
  + 内存是零散的：维护一个列表，记录哪些内存块是可用的，空闲列表法(free list)
+ 在并发情况下分配内存是不安全的，解决这一问题有两种方案：
  + 一是加锁：对分配内存空间的动作进行同步处理
  + 二是把内存分配的动作按照线程划分在不同的空间中进行：每个线程在堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Alllocation Buffer TLAB)，当TLAB用完并分配新的TLAB时，才需要同步锁定
+ 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)
+ 接下来虚拟机将对对象进行必要的设置：对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头(object header)中
+ 从虚拟机角度，此时对象准备就绪，但在程序员看来，还要再执行初始化<init>，才算完成了对象的创建

### 2.3.2　对象的内存布局

+ 对象在内存中的存储的布局可以分为３个区域：对象头(header)、实例数据(instance data)、对齐填充(padding)
  + 对象头包括两部分信息
    + 第一部分用于存储对象自身的运行时数据、如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等，称为"Mark Word"
    + 在32位和64位虚拟机里，markword的大小分别为32bit 和64bit，但数据太多存不下，所以markword被设计成一个非固定的数据结构以便在狭小的空间内存储尽量多的信息，可以根据对象的状态复用自己的存储空间。
    + 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
    + 不过，不是所有的虚拟机实现都在对象数据上保存类型指针；查找对象的元数据信息并不一定要经过对象本身。
    + 另外，如果对象是一个java数组，在对象头中还必须有一块用于记录数据长度的数据，因为虚拟机可以通过普通对象的元数据信息确定java对象的大小，但却不能从数据的元数据中确定数据的大小
  + 实例数据部分是对象真正存储的有效信息
    + 各种类型的字段信息，无论是继承自父类还是子类定义的，虚拟机默认的分配策略是：
    + longs/doubles    ints    shorts/chars    bytes    booleans    oops(Ordinary Object Pointers)
    + 在满足这一前提下，父类的变量出现在子类之前，如果compactFileds参数为true(默认为true)，子类中较窄的变量可以插空到父类的变量中。
  + 对齐填充不是必要的，依虚拟机的设计实现各异

### 2.3.3　对象的访问定位

+ java程序需要通过栈上的reference数据来操作堆上的具体对象
+ reference类型在java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式区定位、访问堆中对象的具体位置，所以对象访问方式取决于虚拟机实现。主要有两种：
  + 使用句柄和直接指针
  + 句柄：java堆中分配出一块内存来作为句柄池，reference中存储的是对象的句柄地址，句柄中包含了指向对象实例数据与类型数据的指针。
  + 其中，对象实例数据的指针指向java堆实例池中的对象实例数据；对象类型数据的指针指向方法区中的对象类型数据(class信息)
  + 直接访问：reference中存储的就是对象地址，对象内容里包含了到对象类型数据的指针。

+ 这两种方式各有优势：
  + 句柄的优势在于reference中存储的是稳定的句柄地址，对象被移动(垃圾回收)时只会改变句柄中的示例数据指针，而不必改变栈中的reference本身。
  + 直接指针则更快，节省了一次指针定位的时间开销