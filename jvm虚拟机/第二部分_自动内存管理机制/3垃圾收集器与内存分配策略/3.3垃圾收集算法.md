### 3.3.1标记－清除算法

+ 最基础的收集算法：首先标记出所有需要回收的对象，在标记完成后统一回收
+ 有两点不足：
  + 一是效率问题，标记和清除的过程都比较慢
  + 二是空间问题，标记清除后会产生大量碎片，不利于大内存对象的分配

### 3.3.2　复制算法

+ 将内存分为大小相等的两块，每次只用一块，当这一块用完了，就把还存活的对象复制到另一块，再把这一块一次性擦除。
  + 优点：实现简单，运行搞笑
  + 缺点：将内存缩小一半，代价太大

* 现在的主流商用做法就是基于这种思路的：将内存分为一块较大的edge空间，和两块survivor。每次回收时，就把edge和一块survivor中存活的对象复制到另一块survivor中，再把edge和第一块survivor清除。大小比例：8:1；当survivor空间不够时，可以依赖老年代进行分配担保
* 如果另一块survivor没有足够空间存放上一次新生代收集下来的存货对象时，这些对象将直接通过分配担保机制进入老年代

### 3.3.3　标记－整理算法

+ 老年代中对象存活率较高，在不想浪费内存做复制的情况下，复制算法不再适用。
+ 标记－整理算法，在标记后，不是直接清除可回收对象。而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

### 3.3.4 分代收集算法

+ 根据对象存活周期的不同将内存划分为几块，一般是分为新生代和老年代。
+ 新生代一般同用改进的复制算法
+ 老年代酌情使用标记－清除或标记－整理

