### 3.4.1枚举根节点

+ 要判断引用链，就要先找到GC roots节点。
+ 可作为GC  roots的节点主要在全局性引用(常量和类静态属性)与执行上下文（栈帧中的本地变量表）
+ 但是方法区和栈帧又很大，逐个检查很浪费时间。而且还存在GC停顿问题。
  + GC停顿：在整个分析期间，整个执行过程要被冻结在该时间点，不能一边分析一边发生执行变化
+ 所以目前主流java虚拟机采用准确式GC，执行系统停顿后，不需要再检查，而是直接从一个OOPMAP数据结构中取得相关信息，oopmap在类加载和JIT编译时维护这些信息。

### 3.4.2　安全点

+ 如果为每一条指令都生成oopmap，空间成本太高
+ 所以采用了安全点，安全点上记录了oopmap信息。只有程序运行到安全点才进行GC，安全点选择标准是：“是否具有让程序长时间执行的特征”
  + 方法调用、循环跳转、异常跳转等

+ 如何在GC发生时让线程都跑到安全点停下来？
  + 抢先式中断：首先都中断，对还没跑到安全点上的线程，恢复它让它跑到安全点。现在没人用
  + 主动式中断：设置一个中断标志，让线程轮询这个标志，当需要暂停线程时，就把中断标志设为真，轮询到的各个线程逐渐中断。

### 3.4.3 安全区域

+ 安全点的问题在于，只适用于被分配了时间片的线程，对于sleep或blocked状态的线程，无法执行到安全点。
+ 所以安全区域扩展了安全点：
  + 安全区域：在一段代码片段中，引用关系不发生变化

+ 在进入安全区域时，线程要标识自己进入了安全区，离开安全区时，要检查是否正在进行GC，如果是的话，要等GC完了才离开安全区。
+ 好处：JVM发起GC时，不用管标识自己为safe region状态的线程了

