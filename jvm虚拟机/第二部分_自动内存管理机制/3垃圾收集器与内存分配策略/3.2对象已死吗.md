+ 为什么要去了解GC和内存分配：
  + 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，就需要对这些自动化的技术实施监控和调节
  + 程序计数器、虚拟机栈和本地方法栈三个区域随线程而生，随线程而灭
  + 而JAVA堆和方法区部分内存的分配和回收都是动态的，GC关注的是这部分内容

### 3.2.1 引用计数算法

+ 给对象添加一个引用计数器，每当被引用，计数器的值就加一，当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可再使用的
+ 引用计数算法简单高效，但主流JAVA虚拟机不采用
+ 因为它很难解决循环引用的问题，当两个对象相互引用时，哪怕两个对象都不能再访问，但因为相互引用，导致它们的引用计数都不为零

### 3.2.2　可达性分析算法

+ 主流java , c# ,lisp等语言都是通过可达性分析(reachability analysis)来判定对象是否存活的。
+ 该算法通过一系列的称为“GC roots”的对象作为起始点，从这些节点向下走过的路径称为引用链，如果一个对象从图论上无法从GC roots到达，则该对象是不可达的，判定可回收。
+ 在java语言中，可作为GC roots对象的包括以下几种：
  + 虚拟机栈(本地变量表中)引用的对象
  + 方法区中类静态属性引用的对象
  + 方法区中常量引用的对象
  + 本地方法栈中native方法引用的对象

### 3.2.3 再谈引用

+ jdk1.2之前，引用的定义很狭隘:
  + 如果reference类型的数据中存储的是另一块内存的起始地址，就称这块内存代表着一个引用(ps:这不就是指针吗？)
+ jdk1.2后，java将引用分为四种类型，强引用，软引用，弱引用，虚引用。引用强度依次减弱：
  + 强引用：在程序代码中普遍存在的，类似"Object obj = new Object()"这类的引用，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象
  + 软引用：在系统将要发出内存溢出异常之前，将被软引用关联的对象列入回收范围再进行一次回收，如果这次回收后还没有足够的内存，才抛出内存溢出异常；使用SoftReference类来实现软引用
  + 弱引用：被弱引用关联的对象只能生存到下一次垃圾回收前；当垃圾收集器工作时，无论当前内存是否足够，都会被回收；使用WeakReference类实现弱引用
  + 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是在这个对象被收集器回收时收到一个系统通知；使用PhantomReference类实现呢虚引用

### 3.2.4 生存还是死亡

+ 要真正宣告一个对象死亡，至少要经历两次标记过程
+ java中有finalize()方法，用来给被标记的对象一次自我拯救的机会
+ 但是作者说finalize()方法属于历史遗留，建议不使用，当它不存在

### 3.2.5　回收方法区

+ 方法区中垃圾回收性价比比较低，不像堆中的新生代，每次回收70%-95%的空间，但虽然低，也是有回收的
+ 永久代中主要回收废弃的常量和无用的类
  + 废弃常量：如果一个常量没有被任何地方引用，就可以被系统清理出常量池
  + 无用类：无用类的判断比较复杂，需要同时满足以下三个条件：
    + 该类所有的实例都已被回收，也就是在堆中不存在该类的任何实例
    + 加载该类的ClassLoader已经被回收
    + 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

