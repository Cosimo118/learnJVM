### 5.3.1 调优前的程序运行状态

### 5.3.2 升级JDK1.6的性能变化及兼容问题

### 5.3.3 编译时间和类加载时间的优化

+ jdk1.6比jdk1.5的类加载时间更长
+ 除了类加载时间，非用户程序耗时还包括：编译时间和垃圾收集时间
  + 编译时间是指虚拟机的JIT编译器(Just In Time Compiler)编译热点代码的耗时；
  + java语言为了实现跨平台的特性，java代码编译出来后形成的Class文件中存储的是字节码(ByteCode)，虚拟机通过**解释**方式执行字节码命令，比起c/c++**编译**成本地二进制代码来说，速度要慢不少
  + 为了解决程序解释执行的速度问题，JDK1.2之后，虚拟机内置了两个运行时编译器，如果一段Java方法被调用次数达到一定程度，就会被判定为热代码交给JIT编译器**即时编译**为本地代码，提高运行速度
  + Java的运行期编译最大的缺点就是它进行编译需要消耗程序正常的运行时间，这也就是上面所说的**编译时间**
+ 虚拟机运行在client模式时，使用的是一个代号为C1的轻量级编译器；运行在server模式，使用到相对重量级的c2编译器。

### 5.3.4 调整内存设置控制垃圾收集频率

+ 类加载和编译时间在程序的启动时间影响较大，但gc回收则贯穿程序整个生命，所以它的性能影响是最关键的。
+ 作者发现新生代频繁gc是因为新生代太小，扩大了新生代内存
+ 老年代频繁gc则是为了扩容，不如直接把老年代内存固定
+ 调整后，大幅度减小了eclipse的启动时间

### 5.3.5 选择收集器降低延迟

+ 观察cpu资源使用情况和GC停顿时间，发现cpu资源富余而老年代full gc停顿时间过长
+ 所以手动替换掉client模式的虚拟机中默认的新生代、老年代串行收集器做铺垫
+ 既然是为了降低停顿时间，CMS是很适合的方案，运用CMS后，老年代停顿时间降低了很多