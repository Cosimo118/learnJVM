### 5.2.1　高性能硬件上的程序部署策略

+ 背景是这样的，原来用32位虚拟机的团队，换了一个大内存，给java堆分配了大空间，结果出现网站失去响应问题。因为大堆导致回收时的停顿时间太长，客户端跟服务器就失去联系了。
+ 而且由于程序设计的关系，访问文档时要把文档从磁盘提取到内存中，导致内存中出现很多由文档序列化产生的大对象，这些大对象也都进入了老年代，没有在minor GC中清理，导致FULL GC太频繁，总是出现响应停顿。
+ 在高性能硬件上部署程序，目前主要有两种方式：
  + 通过64位JDK来使用大内存
  + 使用若干个32位虚拟机建立逻辑集群来利用硬件资源
+ 第一种64位的方式可能存在以下问题：
  + 大内存回收导致的长时间停顿
  + 64位jdk性能测试低于32位
  + 需要保证程序足够稳定，一旦出现堆溢出，十几G的dump文件无法生成和分析
  + 相同程序在64位JDK消耗的内存一般比32位大，因为指针膨胀和数据类型对齐补白等。
+ 第二种逻辑集群：在一台物理机上启动多个服务器进程，分别分配不同端口，在前段搭载负载均衡器，以反向代理的方式来分配访问请求。其可能存在的问题有：
  + 应当尽量避免竞争全局资源，尤其是磁盘资源
  + 很难高效率利用某些资源池：例如线程池
  + 各个节点不可避免受到32位系统的内存限制
  + 大量使用本地缓存的应用，在逻辑集群造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，这是可以考虑改为集中式缓存

### 5.2.2　集群间同步导致的内存溢出

+ 由于信息有传输失败需要重发的可能性，在确认所有节点都收到正确信息前，发送的信息必须在内存中保留，因为网络交互很频繁，当网络情况不能满足传输要求时，重发数据在内存中不断累积，就产生了内存溢出

### 5.2.3 堆外内存导致的溢出错误

+ 操作系统对每个进程能管理的内存是有限制的，direct memory内存并不算入堆里，因此它只能在剩下的内存中分出一部分。
+ 垃圾收集进行时，direct memory不能像新生代和老年代一样，发现空间不足后通知收集器回收，它只能等老年代满了之后full gc，然后“顺便”帮它清理。否则只能等到抛出异常时，在catch里调用"system.gc()"，要是system还不理，就只能抛异常了。
+ 除了java堆和永久代之外，以下区域也占据了相当大的内存，需要留意：
  + direct memory
  + 线程堆栈
  + socket缓冲区，每个socket链接都有receive和send两个缓冲区，分别占37KB和25KB，连接多的话这块内存占用也很可观，可能报IOException: Too many open files异常
  + JNI代码
  + 虚拟机和GC

### 5.2.4 外部命令导致系统缓慢

+ 这家团队在代码中执行了一个外部脚本，使用Runtime.getRuntime().exec()方法来调用的。这种方式很消耗资源，因为java虚拟机执行这个命令的过程是：首先克隆一个当前进程，再用这个克隆出的新进程来执行外部命令，最后再退出这个进程。导致系统消耗很大。

### 5.2.5 服务器JVM进程崩溃

+ 这里是因为要和另一个网站对接，但是双方服务速度不对等，时间变长就累积了很多的web服务没有完成，导致在等待的线程和socket链接越来越多，最终崩溃。
+ 修复方式是：将异步调用改为生产者/消费者的消息队列实现

### 5.2.6 不恰当数据结构导致内存占用过大

+ 这里运行时要加载一个80MB，包含100万个hashmap<long,long>，这些对象不会被minor gc清理，所以试图移到survivor里，survivor放不下又通过分配担保进入老年区，这就很慢了。
+ 而且hashmap要经过层层包装，16B的两个long数据，包装好之后有88B，空间效率太低。

### 5.2.7 由Windows虚拟内存导致的长时间停顿

+ 挺小的一个程序结果隔一段时间就出现一次长时间gc，因为被windows虚拟内存管理把内容移到磁盘上了。