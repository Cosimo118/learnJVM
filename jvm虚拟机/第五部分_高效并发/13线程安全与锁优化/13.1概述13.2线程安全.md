## 13.1 概述

+ 面向过程思想：把数据和过程分别作为独立的部分来考虑，数据代表问题空间中的客体，程序代码用来处理这些数据
+ 面向对象思想：把数据和行为都看作是对象的一部分，可以让程序员能以符合现实世界的思维方式来编写和组织程序

## 13.2 线程安全

+ 线程安全的严格定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用了这个对象的行为都可以获得正确的结果，那这个对象是线程安全的
+ 线程安全的代码特征 ：代码本身封装了所有必要的正确性保障手段，调用者无需关心多线程的问题

### 13.2.1 java语言中的线程安全

+ java语言中共享数据可根据安全性分为以下几类：

  + 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立

  1. 不可变：一定是安全的，比如final；
     + javaAPI中符合此类的类型包括：String，Long，Double，BigInteger，BigDecimal等
  2. 绝对线程安全：很难，java中标注自己是线程安全的类，大多数都不是绝对的线程安全
  3. 相对线程安全：大部分线程安全类属于此类：
     + 例如：Vector、HashTable、Collections的SynchronizedCollections()方法包装的集合等
  4. 线程兼容：指对象本身不是线程安全的，但可以在调用时正确使用同步手段来保证对象在并发环境中可以安全使用
     + javaAPI中大部分类属于此列：ArrayList和HashMap等
  5. 线程对立：无论调用端是否同步，都无法多线程并发，java中很少，应尽力避免

### 13.2.2 线程安全的实现方法

+ 第一种是调用时代码要写好，第二种依靠虚拟机提供的同步和锁机制，主要讲解第二种

1. 互斥同步：
   + 又叫阻塞同步，在多线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用(信号量可以多个)
   + 临界区、互斥量、信号量都是主要的互斥方式
   + 最基本的是synchronized关键字，但阻塞和唤醒会导致频繁切换用户态和内核态，时间长。所以synchronized是重量级操作，谨慎使用
   + ReentrantLock比synchronized多了三个功能，但现在也不好用了，建议还是用 synchronized
     + 等待可中断：等半天就先不等了，先干别的去
     + 可实现公平锁：公平(先来后到排队)，不公平(都有机会，synchronized就是不公平锁)
     + 锁绑定多个条件，(synchronized每个条件一个锁，好几个条件就要加好几把锁)

2. 非阻塞同步
   + 阻塞和非阻塞的最大区别：阻塞是悲观的(不关风险大小都得加锁)，非阻塞是乐观的(能不加就先不加，出了事再补救)
   + 乐观并发策略需要“硬件指令集的发展”，因为需要保证**操作和冲突检测**这两步的原子性。总不能加锁来保证吧，所以只能等硬件了。

3. 无同步方案
   + 如果一个方法本来就不涉及共享数据，那它就无需任何同步措施来保证正确性
   + **可重入代码**，也叫纯代码。最简单的判断原则：输入确定时，输出也能随之确定，不会改变。
     + 其具有一些特征：不依赖存储在堆上的数据和公用系统资源，用到的状态量都从参数中传入，不调用非可重入的方法等
   + **线程本地存储**，把这些共享数据的代码保证在同一个线程中执行。例如，web中的**一个请求对应一个服务器线程**