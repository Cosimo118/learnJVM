### 13.3 锁优化

+ 这一段真的难。。
+ 锁优化技术包括：适应性自旋锁、锁消除、锁粗化、轻量级锁、偏向锁等

### 13.3.1 自旋锁与适应性自旋

+ 互斥同步对性能最大的影响是**阻塞的实现**，挂起和恢复线程都要转到内核态。
+ 在很多时候，共享数据的锁定状态只持续非常短的时间，为了这点时间挂起和恢复线程不值当的。
+ 所以，不如让后面请求锁的那个线程执行个忙循环(自旋)，但又不放弃cpu执行时间。
+ **适应性自旋**就是不固定自旋时间。由前一次在该锁上的自选时间及锁的拥有者状态来决定。虚拟机通过分析历史数据变得越来越智能

### 13.3.2 锁清除

+ 指虚拟机在JIT运行时，对一些代码层面要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除(消除没必要的锁)
+ 如果判断一段代码中，堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当栈上数据对待

### 13.3.3 锁粗化

+ 如果虚拟机探测到有一串这样零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展到整个操作序列的外部，这样就避免了反复加锁带来的不必要性能消耗

### 13.3.4 轻量级锁

+ 本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗
+ 大概意思相当于贴了个封条，锁不住，但能起个警示作用。一旦有人竞争，就膨胀到重量级锁。
+ 轻量级锁提升性能的依据是：对于大部分的锁，在整个同步周期内都是不存在竞争的

### 13.3.5 偏向锁

+ 这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步