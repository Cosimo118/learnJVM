## 11.3 编译优化技术

### 11.3.1 优化技术概览

+ 这些代码优化变换是建立在代码的某种中间表示或机器码上，而非java源码上的
+ 优化时，**方法内联**因为可以取出方法调用的成本，为其他优化建立良好基础，通常是最靠前的步骤
+ 列举几项最有代表性的优化技术
  + 语言无关优化：公共子表达式消除
  + 语言相关优化：数组范围检查消除
  + 最重要的优化：方法内联
  + 最前沿的优化：逃逸分析

### 11.3.2 公共子表达式消除

+ 如果一个表达式E已经计算过了，并且距离上次计算，E中所有变量的值都没有变化，E就不用再算了，直接拿来用
+ 单个基本块里的优化叫**局部公共子表达式消除**
+ 多个块中的优化叫**全局公共子表达式消除**

### 11.3.3 数组边界检查消除

+ java和c/c++不一样，涉及到数组的操作会有边界检查，报ArrayIndexOutOfBoundsException，本来是好事，但对拥有大量数组访问的程序，这是一种性能负担
+ 数组边界检查消除，就是尽量减少对数组边界的检查。
+ 类似的还有**隐式异常处理**，把能经过判断可能发生异常的语句自动转换成异常，这样可以省下一次判断的操作

### 11.3.4 方法内联

+ 方法内联按理说在java里是做不到的，因为java中大部分的实例方法都是由invokevirtual指令调用的**虚方法**，多态的情况下无法确定该连哪个。多态的确定又要到运行期，编译期搞不定
+ 解决方案是引入：**类型继承关系分析**(CHA)技术
  + 内联时，遇到非虚方法，直接连。
  + 遇到虚方法，就向CHA查询此方法有几个版本，如果只有一个版本，可以内联。但这算激进优化，要留逃生门，这种称为**守护内联**
  + 如果查出来多个结果，**内联缓存**，每次记下调用的版本，只要一直一样，就可以一直内联下去，直到遇到不一样，就取消内联

### 11.3.5 逃逸分析

+ 方法逃逸：一个对象在方法中被定义后，又被外部方法所引用
+ 线程逃逸：被外部线程访问到
+ 如果能证明一个对象不会逃逸到方法或线程外，就可以对其进行优化
  + 栈上分配：堆回收挺麻烦的，反正也在方法内，就把对象分配在栈上，跟栈帧同生共死
  + 同步消除：既然变量逃逸不出线程，就没有必要搞同步了，又省点事
  + 标量替换：干脆不生成对象了，直接生成几个对象里边的成员变量用

