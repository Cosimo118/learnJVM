+ java虚拟机的指令由一个字节长度的、代表某种特定操作含义的数字(**操作码**)及跟随其后的零至多个代表此操作所需参数(**操作数**)构成
+ java虚拟机采用**面向操作数栈**的架构，而非寄存器架构，所以大部分指令只有一个操作码
+ 字节码指令集是一种优劣势都很突出的指令集架构：
  + 特点：
    + 限制操作码长度为**一个字节**(0-355)，限制了操作码总数；
    + class文件放弃编译后代码的操作数长度对齐，意味着虚拟机处理那些超出一个字节的数据时，要在运行时从字节中重建数据
  + 优点：省略了填充，节省空间；编译代码短小精悍
  + 缺点：重建数据损失性能；操作码总数受限
+ java虚拟机解释器的基本执行模型如下：

```java
do{
    自动计算PC寄存器的值加1；
    根据PC寄存器的指示位置，从字节码流中取出操作码；
    if（字节码存在操作数）	从字节码流中取出操作数
    执行操作码所定义的操作；
}while(字节码流长度>0)
```

### 6.4.1 字节码与数据类型

+ 在java虚拟机的指令集中，大多数的指令包含了其操作所对应的数据类型信息，比如：iload指令用来从局部变量表中加载int型数据到操作数栈中
+ 考虑到操作码长度受限，指令集将会被设计成**非完全独立**的，即并非每种数据类型和每种操作都有对应的指令
+ 大部分指令没有支持byte、char、short，完全没有支持boolean，因为编译器会在编译期将byte和short类型的数据**带符号扩展**(sign-extend)为相应的int类型数据，将boolean和char类型数据**零位扩展**(Zero-extend)为int
+ 字节码操作按用途大致可分为9类

### 6.4.2 加载和存储指令

+ 用于将数据在栈帧中的局部变脸表和操作数栈之间来回传输，包括：
  + 将一个局部变量加载到操作栈
  + 将一个数值从操作数栈存储到局部变量表
  + 将一个常量加载到操作数栈

### 6.4.3 运算指令

+ 用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶
  + 加法指令
  + 减法指令
  + 乘法指令
  + 除法指令
  + 求余指令
  + 取反指令
  + 位移指令
  + 按位与指令
  + 按位或指令
  + 按位异或指令
  + 局部变量自增指令
  + 比较指令
+ java虚拟机规范规定，在处理整型数据时除了除法和求余，其他不应该抛出异常（溢出不抛异常）
+ 浮点数：
  + 必须完全支持IEEE754的非正规浮点数值和逐级下溢运算规则
  + 浮点数运算结果要遵循默认舍入模式
  + 浮点数转化为整数采取**向零舍入模式**（向下取整）
  + java虚拟机在处理浮点数运算时，不会抛出任何异常。溢出时，使用有符号的无穷大来表示；如果运行结果没有明确数学定义的话，输出NaN

### 6.4.4 类型转换指令

+ 用来转换数据类型(**显式类型转换**)
+ java虚拟机直接支持**宽化类型转换**：
  + int 到 long float double
  + long 到 float double
  + float 到double
+ 而在**窄化类型转换**时，则必须**显式类型转换**
+ int或long的窄化：简单丢弃除最低位N个字节以外的内容，可能导致数据错误，精度丢失，符号变化
+ 浮点数窄化成整数int或long有如下规则：
  + 如果浮点数是NaN，转换结果就是0
  + 如果浮点数不是无穷大，浮点数向零舍入模式取整，得到整数值v，如果v在范围内，可得
  + 否则，按照v的符号，转化为整数类型能表示的最大或最小的数
+ double窄化成float：
  + 最接近数舍入模式得到float类型表示的数字，如果结果绝对值过小无法用float表示，返回float类型的正负零；绝对值过大，返回float的无穷大；double的NaN，返回float的NaN
+ 数值类型的窄化转换指令永远不可能导致虚拟机溢出

### 6.4.5 对象创建与访问指令

+ 对象创建后，可以通过对象访问指令获取对象实例或对象实例中的字段或者数据元素：
  + 创建类实例的指令
  + 创建数组的指令
  + 访问类字段和实例字段
  + 把一个数组元素加载到操作数栈的指令
  + 把一个操作数栈的值存储到数组元素中的指令
  + 取数组长度的指令
  + 检查类实例类型的指令

### 6.4.6 操作数栈管理指令

+ 用于直接操作操作数栈的指令：
  + 将操作数栈栈顶的一个或两个元素出栈
  + 复制栈顶的一个或两个数值，并将复制值或双份复制值压入栈中
  + 将栈顶两个元素互换

###  6.4.7 控制转移指令

+ 让java虚拟机有条件或无条件地从指定的位置指令继续执行程序
  + 条件分支
  + 复合条件分支
  + 无条件分支
+ 和前面算术运算规则类似，整型都转化为int进行比较，浮点数则按照指令比较再返回int值到栈顶，再调用控制转移指令

### 6.4.8 方法调用和返回指令

+ 第八章详解

### 6.4.9 异常处理指令

+ 抛异常(throw)由athrow指令完成
+ 处理异常(catch语句)不是由字节码指令来实现，而是用异常表来完成的

### 6.4.10 同步指令

+ java虚拟机支持方法级同步和方法内部一段指令序列的同步，都是用**管程(monitor)**实现的
+ 方法级同步是隐式的，无需通过字节码指令来控制，管程就是令牌
  + 在方法执行期间，执行线程持有了管程，其他任何线程无法再获取到该管程
  + 正常执行，管程正常释放；抛异常，在抛异常同时释放管程
+ 同步一段指令集序列(同步语句)要用synchronized语句块，monitorenter和monitorexit两条指令来支持synchronized

