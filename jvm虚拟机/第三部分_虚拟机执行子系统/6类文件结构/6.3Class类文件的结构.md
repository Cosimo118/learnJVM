+ 任何一个Class文件都对应着唯一一个类或接口的定义信息
  + 但类或接口不一定都得定义在文件里(也可以通过类加载器直接生成)
  + 将任意一个有效的类或接口所应当满足的格式称为"Class文件格式"，实际上并不一定以磁盘文件的形式存在
+ Class文件是一组以8位字节为基础单位的二进制流
  + 紧密排列，没有分隔符
  + 对大于8位字节空间的数据，采取高位在前(大端存储)的方式
+ Class文件格式采用类似C语言结构体的伪结构来存储数据，伪结构中只有两种数据结构：
  + 无符号数：基本数据类型，以u1、u2、u4、u8来代表1,2,4,8个字节的无符号数，可用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值
  + 表：由多个无符号数或者其他表作为数据项构成的符合数据类型，所有表都习惯性地以"_info"结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。
  + 无论无符号数还是表，当描述同一类型但数量不定的多个数据时，会使用一个前置的容量计数器，再跟若干个连续的数据项。称这一系列连续的数据为某一类型的集合

### 6.3.1　魔数与Class文件的含义

+ 每个class文件的头4个字节称为魔数，用来确定这个文件是否为一个能被虚拟机接受的Class文件
  + 使用魔数而非扩展名来进行识别主要是基于安全方面的考虑，因为扩展名可以随意更改
  + Class文件的魔数是:0xCAFEBABE
+ 第5,6个字节是次版本号，第7,8个字节是主版本号，1.7是51.0

### 6.3.2 常量池

+ 紧跟在版本号后面的是常量池入口
+ 常量池是Class文件中的资源仓库，是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，还是在Class文件中第一个出现的表类型数据项目
+ 常量池入口放置一个u2类型数据，代表常量池容量，**不是从0开始，而是从1开始**。
  + 将0空出来是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义
+ 常量池中主要存放两大类常量：**字面量**(literal)和**符号引用**(symbolic references)
  + 字面量比较接近java中的常量，如文本字符串String、声明为final的常量值等
  + 符号引用则属于编译原理的概念，包括三类：
    + 类和接口的全限定名(Fully Qualified Name)
    + 字段的名称和描述符(Descriptor)
    + 方法的名称和描述符
+ Java代码在javac编译时，不像c++一样进行连接，而是在虚拟机加载Class文件时**动态连接**
  + 也就是说，Class文件中不会保存各个方法和字段的最终内存信息，这些符号引用不经过运行期转换就无法得到真正的内存地址
  + 当虚拟机运行时，需要从常量池活的对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中
+ 常量池中每个**常量都是一个表**，截止1.7，java共有14种结构不相同的表结构数据
  + 这14种表的开始第一位都是一个u1类型的标志位，代表这个常量属于哪种常量类型
+ 常量池中的14种常量项的结构总表，请查阅周志华jvm第二版p172

### 6.3.3 访问标志

+ 常量池结束之后的两个字节代表**访问标志(access_flags)**，用于识别一些类或者接口层次的访问信息
  + 例如：这个Class是类还是接口；是否为public类型；是否为abstract类型；是否为final等
+ 没有使用到标志位的统一置为0，**各个标志位做或运算得到最终结果**

### 6.3.4 类索引、父类索引与接口索引集合

+ 类索引(this_class)和父类索引(super_class)都是一个u2类型的数据
+ 接口索引(interfaces)是一组u2类型的数据的集合
+ class文件中由这三项数据来确定类的**继承关系**



+ 类索引、父类索引和接口索引按顺序排列在访问标志后
+ 类索引和父类索引的u2索引值指向一个CONSTANT_Class_info的类描述符常量，通过这个常量中的索引值又可以找到定义在CONSTANT_Utf-8_info类型的常量中的全限定名字符串

### 6.3.5 字段表集合

| 类型           | 名称             | 数量             |
| -------------- | ---------------- | ---------------- |
| u2             | access_flags     | 1                |
| u2             | name_index       | 1                |
| u2             | descriptor_index | 1                |
| u2             | attributes_count | 1                |
| attribute_info | attributes       | attributes_count |

+ access_flags是字段修饰符，存放了标志位信息，什么public,private,synthetic呀
+ name_index是简单名称，就是字段和方法名字，不用带参数
+ descriptor_index用来描述字段的数据类型，方法的参数列表(数量，类型和顺序)和返回值
  + 8种基本数据类型和void都用一个大写字母表示
  + 对象类型用L加对象的全限定名表示
  + 数组类型每一层维度用 一个[来表示，例如：int[]被记录为“[I"
+ 用描述符来描述方法时，先参数列表，后返回值的顺序，参数列表按顺序放在一个小括号()里
  + 例如：void inc()的描述符为()V
  + java.lang.String toString()方法描述符为()Ljava/lang/String

+ 字段表集合中不会列出从超类或者父接口中继承来的字段，但有可能列出原本java代码中不存在的字段
  + 例如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段
+ 到descritor_index为止，字段表所包含的固定数据项目就结束了，后面的attributes是可选的属性表

### 6.3.6方法表集合

+ 方法表的结构和字段表完全一致
  + 在访问标志上有些许区别
  + 在属性表集合的可选项上有所区别
+ 方法的定义可以通过访问标志、名称索引、描述符索引表示，方法里的代码则在编译成**字节码指令**之后，存放在方法属性表集合中一个名为**code**的属性里

+ 如果父类方法没有在子类中重写，方法表集合中就不会出现来自父类的方法信息，但有可能出现由编译器自动添加的方法，例如类构造器"\<client>"和”\<init>“
+ java语言中的重载(Overload)，除了要与原方法具有相同的简单名称，还要求特征签名不同。
  + 特征签名是一个方法中各个参数在常量池中的字段符号引用的集合。
  + 因为只考虑参数，所以不能只改变返回值来重载方法
  + 但在class文件里，参数相同返回值不同的两个方法可以合法共存，因为在class文件里，描述符算上了返回值，所以描述符不同的两个方法，就可以合法共存

### 6.3.7 属性表集合

+ 属性表的限制相当宽松，不要求严格顺序，只要不重名，任何人实现的编译器都可以向属性表中写入自己定义的属性信息。
+ 每个属性的名称需要从常量池中引用一个CONSTANT_Utf-_info类型的常量来表示，再引入一个u4类型的长度属性说明属性的长度，其余部分可以自定义

1. Code属性：
   + java程序方法体中的代码经过javac编译器处理后，最终变为字节码指令，就存储在code属性内
   + 不是所有的方法表都有code属性，接口或抽象类中就没有
   + code属性是class文件中最重要的一个属性。将java程序中的信息分为**代码**(code，方法体中的java代码)和**元数据**(metadata,包括类、字段、方法定义和其他信息)两部分；code属性就是用来描述代码的，而其他所有的用来描述元数据。
   + 观察发现，即便没有定义任何局部变量，locals也等于1：因为在任何实例方法中，都可以通过this关键字访问到此方法所属的对象。所以，locals和参数表都留了一个位子给this。
   + 如果把方法声明为static，参数值就不受this影响，而变为0了
   + 字节码之后的部分是方法的**显式异常处理表**(异常表)集合，非必须存在
   + **异常表**是java代码的一部分，编译器使用异常表而不是简单的跳转命令来实现java异常及finally处理机制
2. Exceptions属性
   + 这里的Exceptions是在方法表中和Code属性平级的一级属性，作用是列举出方法中可能抛出的**受查异常**(checked exceptions)，也就是方法描述时在throws关键字后面列举的异常
3. LineNumberTable属性
   + 用于描述**java源码行号**和**字节码行号**之间的对应关系
   + 如果选择不生成这项属性，抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序时，也无法按照源码行来设置断点
4. LocalVariableTable属性
   + 用于描述栈帧中局部变量表中的变量与 java源码中定义的变量之间的关系
5. SourceFile属性
   + 用于记录生成这个class文件的源码文件名称
   + 大多数的类，类名和文件名一致，但特殊情况（内部类等）例外
   + 如果不生成这项属性，抛出异常时，堆栈中将不显示出错代码所属的文件名
6. ConstantValue属性
   + 用来通知虚拟机自动为静态变量赋值，只有被static修饰的类变量才可以使用此属性
7. InnerClasses属性
   + 用于记录内部类与宿主类之间的关联
   + 如果一个类中定义了内部类，编译器将会为它以及它所包含的内部类生成InnerClasses属性
8. Deprecated及Synthetic属性
   + 都属于标志类型的布尔属性，只分有没有
   + Deprecated意思是不再推荐使用
   + Synthetic指这段代码不是java源码产生的，而是编译器自行添加的
9. StackMapTable属性
   + 在虚拟机类加载的字节码验证阶段被新类型检查验证器使用
10. Signature属性
    + 出现在类、字段表和方法表结构的属性表中，为类型变量或参数化类型记录泛型签名信息。
    + 弄这个的原因是：原本的java支持泛型靠的是擦除法，在编译后擦除泛型信息，擦除法的弊端是，运行期无法区分泛型和基本类型。
    + 这个属性用于记录泛型，这样在运行期也能知道一个类型是不是泛型
11. BootstrapMethods属性
    + 用于保存invokedynamic指令引用的引导方法限定符

