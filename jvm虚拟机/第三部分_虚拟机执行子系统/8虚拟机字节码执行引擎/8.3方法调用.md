## 8.3 方法调用

+ 方法调用不等于方法执行，调用阶段的唯一任务就是确定被调用方法的版本**(即调用哪一个方法)**，暂时不涉及方法内部的具体运行过程
+ 但class文件的编译过程不包含连接步骤，一切方法调用在class文件里存储的都是符号引用，而非直接引用，这个特性的好处是强大的动态扩展能力，缺点是让方法调用过程变得复杂，迟迟无法确定直接引用

### 8.3.1 解析

+ **解析(resolution)**：调用目标在程序代码写好，编译器编译时就已经确定，运行期不变的一类调用
+ java中符合**编译期可知，运行期不可变**要求的方法，主要有**静态方法**和**私有方法**两大类。他们都不可能通过继承或别的方式重写出其他版本，所以很适合解析
+ java虚拟机里提供了5条方法调用字节码：
  + invokestatic：调用静态方法
  + invokespecial：调用\<init>方法，私有方法，父类方法
  + invokevirtual：调用虚方法
  + invokeinterface：调用接口方法
  + invokedynamic：运行时动态解析出调用点限定符所引用的方法，再执行该方法

+ 被invokestatic和invokespecial调用的称为非虚方法，其余的是虚方法
+ 注意：**final方法**被invokevirtual调用，但不是虚方法
+ 解析调用一定是静态过程，编译期确定，解析阶段就把符号引用都转换掉了。**分派(dispatch)**则不一定

### 8.3.2 分派

+ 本节讲解**重写(override)**和**重载(overload)**在java虚拟机中的实现

1. 静态分派
   + 变量有两个类型，静态类型和实际类型，编译器在重载时是通过参数的静态类型作为判定依据的，因为静态类型是编译期可知的。
   + 所有依赖静态类型来定位方法执行版本的分派动作称为静态分派，典型应用是**方法重载**
   + 静态分派寻找适合方法版本的过程：先找对应的静态类型，找不到向上自动类型转换，还找不到就自动装箱，还找不到就序列化(装箱类实现的接口)，还找不到就Object，还找不到才是数组类(变长参数的重载优先级最低)

```java
Human man = new Man();//变量man的静态类型是Human，实际类型是Man
```

2. 动态分派
   + 在运行期根据实际类型确定方法执行版本的分派过程叫做动态分派
   + 动态分派和**重写**联系密切
   + 重写发生时，两个静态变量相同的方法运行出了不同的结果，就是因为实际变量不同。
   + java虚拟机运用动态分派时，使用了*invokevirtual*指令的多态查找过程。过程如下：
     1. 找到**操作数栈**顶的第一个元素所指对象的实际类型
     2. 在该类型中找到相符的方法
     3. 否则从下向上依次对父类做搜索
   + 因为和操作数栈有关系，所以*invokevirtual*指令实现了动态，可以把常量池中的类方法符号引用解析到不同的直接引用上，这就是方法重写的本质。

3. 单分派和多分派

   + 方法的接受者与方法的参数统称为方法的**宗量**，根据分派基于多少种宗量，可以将其分为单分派和多分派
     + 单分派：根据一个总量选择目标方法
     + 多分派：根据多个宗量

   + java的编译阶段静态分派过程是多分派的，既考虑静态类型，也考虑方法参数
   + 运行阶段动态分派的过程则是单分派的，只考虑接受者的实际类型。
   + java是一门**静态多分派，动态单分派**的语言

4. 虚拟机动态分派的实现

   + 因为动态分派很频繁，考虑性能，通常在方法区中建立一个**虚方法表**，里面存放各个方法的实际入口地址

### 8.3.3 动态类型语言支持

1. 动态类型语言
   + JDK1.7提供的invokedynamic指令是实现动态类型语言支持的重要环节
     + 动态类型语言：它的类型检查的主体过程是在运行期而不是编译期
     + 静态语言：在编译期就进行类型检查
   + 在动态语言中，**变量无类型而变量值有类型**，编译时最多确定方法名、参数、返回值等信息，而不会去确定方法所在的具体类型

2. JDK1.7与动态类型
   + invokedynamic出来之前，4条方法调用指令固化在了虚拟机的编译阶段。

3. java.lang.invoke包
   + java无法单独地把函数作为参数进行传递，传统做法是设计一个带有compare()方法的comparator接口，以实现了这个接口的对象作为参数。
   + method handle可以让java也拥有类似函数指针的工具
     + 本质上，reflection和methodhandle都在模拟方法调用，不同的是reflection是代码层次的模拟，methodhandle是字节码层次的模拟
     + reflection是重量级，methodhandle轻量级
     + reflection是java语言的内容，methodhandle则可服务于java虚拟机上所有语言

4. invokedynamic指令
   + 和methodhandle一样是为了把查找目标方法的决定权从虚拟机转接给具体用户代码

