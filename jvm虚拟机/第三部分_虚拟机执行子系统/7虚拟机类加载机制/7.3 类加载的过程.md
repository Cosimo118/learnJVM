## 7.3 类加载的过程

+ 详解**加载、验证、准备、解析、初始化**

### 7.3.1 加载

+ **加载**阶段，虚拟机要完成3件事：
  + 通过一个类的全限定名来获取定义此类的二进制字节流
  + 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  + 在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
+ 虚拟机的要求不具体，实现的灵活度很大，例如，对第一条，并没有规定二进制流只能来自class文件，因此：
  + 从zip包中读取：jar,war
  + 从网络中获取：applet
  + 运行时计算生成：动态代理技术
  + 由其他文件生成：JSP
  + 从数据库中读取
+ 在加载过程中对**数组类和非数组类**有所不同
  + 非数组类：可控性最强，可以使用系统提供的引导类加载器，也可以使用用户自定义的类加载器
  + 数组类：本身由java虚拟机创建，不通过类加载器加载。但是数组类的元素类型最终是要靠类加载器加载的。数组类创建过程如下：
    + 如果数组的组件类型还是引用类型，那就接着递归
    + 如果不是引用类型了，就把数组标记为与相应的引导类加载器关联
    + 数组类可见性和组件的一致，如果组件类不是引用类型，数组类的可见性默认为public
  + 加载阶段完成后，加载到的二进制字节流就存储在方法区中。然后在**内存(没说是堆)**中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中类型数据的**外部接口**
  + 加载与连接的部分内容是交叉进行的，但开始顺序还是固定的

### 7.3.2 验证

+ 验证是连接阶段的第一步，是为了保证Class文件的字节流中包含的信息符合当前虚拟机的要求且不危害虚拟机自身安全。
+ 如果不检查输入的字节流，可能因载入有害字节流而使系统崩溃
+ 验证阶段大致包括一下4个阶段：**文件格式验证、元数据验证、字节码验证、符号引用验证**
  + 文件格式验证：对字节流的验证，保证其符合Class文件格式规范，且能被当前虚拟机版本处理。目的是保证输入的字节流能正确解析存储在方法区当中，后面的事就不归他管了
  + 元数据验证：对字节码描述的信息进行语义分析。目的是对类的元数据信息进行语义验证，保证不存在不符合Java语言规范的元数据信息
  + 字节码验证：目的是确保程序语义是合法的符合逻辑的，重点对类的方法体进行校验。因为太复杂，所以引入**StackMapTable**来存储
    + StackMapTable：描述了方法体中所有的基本快开始时本地变量表和操作数栈应有的状态。就将字节码验证的类型推导转为类型检查，节约时间。
  + 符号引用验证：发生在**解析**阶段中将符号引用转为直接引用时。可看做是对类自身以外信息进行匹配性校验。

### 7.3.3 准备

+ 正式为**类变量**分配内存并设置类变量初始值的阶段，分配在方法区。
  + 此时仅分配类变量(static)，实例变量会在对象实例化时和对象一块分在java堆里
  + 而且这会只赋**初始值**，是数据类型的零值。

```java
public static int value = 123;	//准备阶段value的值为0
//把value赋值为123的putstatic指令要编译后放在类构造器<clinic>()里，在初始化阶段才执行
public static final int value = 123;//人家final才能在准备阶段就赋值123呢
```

### 7.3.4解析

+ 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
  + 符号引用：用一组符号来描述所引用的目标，符号可以是任何形式的字面量，是要使用时能无歧义的定位到目标即可。
  + 直接引用：直接指向目标的指针，相对偏移量或者是一个能简介定位到目标的句柄。
+ 解析阶段的具体时间没有规定
+ 为了避免对同一个符号引用多次解析，可以将解析结果缓存。invokedynamic除外
+ incokedynamic用于**动态语言支持**，必须等到程序实际运行到这条指令时，才能开始解析。
+ 解析动作主要针对7类符号引用进行，分别对应7种常量类型

| 符号引用     | 常量类型                         |
| ------------ | -------------------------------- |
| 类或接口     | CONSTANT_Class_info              |
| 字段         | CONSTANT_Fieldref_info           |
| 类方法       | CONSTANT_Methodref_info          |
| 接口方法     | CONSTANT_InterfaceMethodref_info |
| 方法类型     | CONSTANT_MethodType_info         |
| 方法句柄     | CONSTANT_MethodHandle_info       |
| 调用点限定符 | CONSTANT_InvokeDynamic_info      |

+ 先分析前四种静态，后三种第8章再讲

1. 类或接口的解析：
   + 如果被解析的类或接口不是数组类型，那就把该全限定名传递给当前类的类加载器，然后还得验证
   + 如果是数组类型，就找到数组元素类型的全限定名，传给类加载器，由虚拟机给这个元素类型包上维度，生成数组对象
   + 解析完成前还得进行符号引用验证
2. 字段解析
   + 要解析一个字段，先解析字段所在的类或接口的符号引用
   + 假设字段所在类或接口为C，之后的搜索步骤如下：
     1. 先在C里边找，**简单名称和字段描述符**都匹配的的字段
     2. 找不到的话递归向C实现的接口中找
     3. 再找不到递归搜索父类
     4. 还找不到就失败，抛出java.lang.NoSuchFiledError
   + 查找成功返回引用后，还得对字段进行权限验证
3. 类方法解析
   + 第一步和字段解析一样，先找类方法所在类C
     1. 类方法和接口方法的符号引用常量类型定义是分开的。如果在类方法表中发现class_index中索引的C是个接口，抛异常
     2. 然后才在C里找这个类方法
     3. 然后在父类里递归找
     4. 否则在接口里找，要是能找到，说明C是个抽象类，查找结束抛异常
     5. 否则，宣告查找失败，抛异常
   + 最后对找到的直接引用进行权限验证
4. 接口方法解析
   + 和前两项一样，先接口
     1. 要是发现C是个类而非接口，抛异常
     2. 在c里找 
     3. 在c的父接口里找
     4. 否则，查找失败，抛异常
   + 接口里的方法默认是public，所以不用再校验权限

### 7.3.5 初始化

+ 类初始化阶段是类加载过程的最后一步，这一步才真正开始执行类中定义的java程序代码(字节码)
+ 换种说法：初始化阶段是执行**类构造器\<clinit>()方法**的过程
  + \<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的。收集顺序就是语句出现顺序。

关于顺序的WARNNING:

```java
public class Test{
    static{
        i = 0;	//可以编译通过
        System.out.print(i);	//“非法向前引用”，编译不通过
    }
    static int i = 1;
}
```

+ \<clinit>()和实例构造器\<init>()不同，不用显式调用父类构造器。虚拟机保证在调用子类的\<clinit>()时，已经先执行完父类的了
+ 因此，父类中的静态语句先于子类赋值
+ 没有静态语句的类可以没有\<clinit>()方法
+ 接口也生成\<clinit>()方法，但执行接口\<clinit>()时，不用先执行父类的。
+ \<clinit>()在多线程环境会正确加锁，同步。如果在一个类的\<clinit>()方法中有耗时很长的操作，可能造成进程阻塞。(很隐蔽的阻塞)